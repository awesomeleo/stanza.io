"use strict";

var SM = require('./stanza/sm');
var MAX_SEQ = Math.pow(2, 32);


function mod(v, n) {
    return ((v % n) + n) % n;
}


function StreamManagement() {
    this.conn = null;
    this.id = false;
    this.allowResume = true;
    this.started = false;
    this.lastAck = 0;
    this.handled = 0;
    this.windowSize = 1;
    this.unacked = [];
    this.pendingAck = false;
}

StreamManagement.prototype = {
    constructor: {
        value: StreamManagement
    },
    enable: function (conn) {
        this.conn = conn;
        var enable = new SM.Enable();
        enable.resume = this.allowResume;
        this.conn.send(enable);
        this.handled = 0;
        this.started = true;
    },
    resume: function (conn) {
        this.conn = conn;
        var resume = new SM.Resume({
            h: this.handled,
            previd: this.id
        });
        this.conn.send(resume);
        this.started = true;
    },
    enabled: function (resp) {
        this.id = resp.id;
    },
    resumed: function (resp) {
        this.id = resp.id;
        if (resp.h) {
            this.process(resp, true);
        }
    },
    failed: function (resp) {
        this.started = false;
        this.id = false;
        this.lastAck = 0;
        this.handled = 0;
        this.unacked = [];
    },
    ack: function () {
        this.conn.send(new SM.Ack({
            h: this.handled
        }));
    },
    request: function () {
        this.pendingAck = true;
        this.conn.send(new SM.Request());
    },
    process: function (ack, resend) {
        var self = this;
        var numAcked = mod(ack.h - this.lastAck, MAX_SEQ);

        this.pendingAck = false;

        for (var i = 0; i < numAcked && this.unacked.length > 0; i++) {
            this.conn.emit('stanza:acked', this.unacked.shift());
        }
        this.lastAck = ack.h;

        if (resend) {
            var resendUnacked = this.unacked;
            this.unacked = [];
            resendUnacked.forEach(function (stanza) {
                self.conn.send(stanza);
            });
        }

        if (this.unacked.length >= this.windowSize) {
            this.request();
        }
    },
    track: function (stanza) {
        var name = stanza._name;
        var acceptable = {
            message: true,
            presence: true,
            iq: true
        };

        if (this.started && acceptable[name]) {
            this.unacked.push(stanza);
            if (!this.pendingAck && this.unacked.length >= this.windowSize) {
                this.request();
            }
        }
    },
    handle: function (stanza) {
        if (this.started) {
            this.handled = mod(this.handled + 1, MAX_SEQ);
        }
    }
};

module.exports = StreamManagement;
